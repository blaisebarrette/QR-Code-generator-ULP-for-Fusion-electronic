// QR Code Generator for Eagle/Fusion Electronics
// This ULP generates QR codes directly on PCB layers
// Version 1.1.0

#usage "<b>QR Code Generator for Fusion Electronics <small>V1.1.0</small></b>\n"
       "<p>"
       "Generate QR codes directly on PCB and Schematic in Electronics design and in Footprint and Symbol in Electronics Library with customizable size.<br>"
       "This ULP allows you to create QR codes that can be placed on various layers "
       "in your Fusion Electronics design."
       "</p>"
       "<p>"
       "<b>Usage:</b><br>"
       "1. Run the ULP and enter your URL<br>"
       "2. Select the size (from 250 mils to 5000 mils, where 1000 mils = 1 inch)<br>"
       "3. Choose the destination layer<br>"
       "The QR code will be automatically placed in the upper-left quadrant."
       "</p>"
       "<p>"
       "<b>Supported Contexts and Layers:</b><br>"
       "<b>PCB/Footprint Layers:</b><br>"
       "- Copper Top (top)<br>"
       "- Copper Bottom (bottom)<br>"
       "- Top Silkscreen (tPlace)<br>"
       "- Bottom Silkscreen (bPlace)<br>"
       "- Top Documentation (tDocu)<br>"
       "- Bottom Documentation (bDocu)<br>"
       "- Document (Docu)<br>"
       "<b>Schematic Layers:</b><br>"
       "- Info<br>"
       "- Guide<br>"
       "<b>Symbol Layers:</b><br>"
       "- Symbols<br>"
       "- Info<br>"
       "- Guide"
       "</p>"
       "<p>"
       "<b>Note:</b> This ULP works on both Windows and MacOS.<br>"
       "For more information, visit: "
       "<a href='https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics'>GitHub Repository</a>"
       "</p>"
       "<author>Author: <b>Blaise Barrette</b></author>"

#require 4.11

// Global variables
string VERSION = "1.1.0";
string LATEST_VERSION = "";
int PosX, PosY;
string LANG;  // Current language code

// Context constants and variable
enum {
    CONTEXT_BOARD,
    CONTEXT_SCHEMATIC,
    CONTEXT_PACKAGE,
    CONTEXT_SYMBOL
};
int currentContext;

// Arrays for localization
string TextKeys[];    // Store keys
string TextValues[];  // Store corresponding values
int TextCount = 0;    // Number of texts loaded

// Function to detect Windows OS
int IsWindows() {
    //Returns 1, if EAGLE is running under Windows (0 for Linux/Mac)
    if ((strsub(argv[0],0,1)=="/") && (strsub(argv[0],0,2)!="//"))
        return 0;
    return 1;
}

// Function to get localized text by key
string getText(string key) {
    for (int i = 0; i < TextCount; i++) {
        if (TextKeys[i] == key) {
            return TextValues[i];
        }
    }
    return key;  // Return key if text not found
}

// Function to add text to arrays
void addText(string key, string value) {
    TextKeys[TextCount] = key;
    TextValues[TextCount] = value;
    TextCount++;
}

// Function to get API URL for current version
string getApiUrl() {
    string csvFile = filedir(argv[0]) + "TempVersionsFile.csv";
    
    // Create a temporary file that will be auto-deleted
    output(csvFile, "wD") {
        printf("");  // Create empty file
    }
    
    string cmd;
    if (IsWindows()) {
        cmd = "powershell -Command \"$ProgressPreference = 'SilentlyContinue'; Invoke-WebRequest -Uri 'https://raw.githubusercontent.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics/main/versions.csv' -TimeoutSec 10 -OutFile '" + csvFile + "'\"";
    } else {
        cmd = "curl -m 10 -s \"https://raw.githubusercontent.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics/main/versions.csv\" > \"" + csvFile + "\"";
    }
    
    int exitCode = system(cmd);
    int i;
    
    if (exitCode != 0) {
        dlgMessageBox(getText("ERROR_NETWORK") + "\n\n" +
                     getText("DEBUG_INFO") + "\n" +
                     "- Exit Code: " + exitCode + "\n" +
                     "- Command: " + cmd + "\n" +
                     "- ULP Version: " + VERSION + "\n\n" +
                     "Please check your internet connection.",
                     getText("BUTTON_OK"));
        return "";
    }
    
    // Read the CSV file into an array
    string csvLines[];
    int nLines = fileread(csvLines, csvFile);
    
    if (nLines <= 1) {  // File must have at least 2 lines (header + data)
        return "";
    }
    
    // Find the latest version available (first line after header)
    if (nLines > 1) {
        string fields[];
        int n = strsplit(fields, csvLines[1], ',');
        if (n >= 4) {
            LATEST_VERSION = fields[0];  // First version is the most recent
        }
    }
    
    string api_url = "";  // Variable to store the API URL
    
    // Loop through lines to find current version
    for (i = 1; i < nLines; i++) {
        string fields[];
        int n = strsplit(fields, csvLines[i], ',');
        if (n >= 4 && fields[0] == VERSION) {
            // Check if version is supported
            if (n >= 5 && fields[4] == "0") {
                dlgMessageBox("Error: This version of the ULP is no longer supported.\n\n" +
                            "Debug Info:\n" +
                            "- ULP Version: " + VERSION + "\n" +
                            "- CSV Line: " + csvLines[i] + "\n\n" +
                            "Please download the latest version to continue:\n" +
                            "https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics/releases/latest",
                            "OK");
                exit(1);
            }
            api_url = fields[3];  // Store the API URL
            break;
        }
    }
    
    return api_url;  // Return the API URL
}

// Function to trim whitespace from string
string trim(string str) {
    string result = "";
    int start = 0;
    int end = strlen(str) - 1;
    
    // Find first non-space character
    while (start < strlen(str)) {
        if (strsub(str, start, 1) != " ") break;
        start++;
    }
    
    // Find last non-space character
    while (end >= 0) {
        if (strsub(str, end, 1) != " ") break;
        end--;
    }
    
    // Extract the trimmed string
    if (start <= end) {
        result = strsub(str, start, end - start + 1);
    }
    
    return result;
}

// Function to load localized texts
void loadLocalizedTexts() {
    LANG = language();
    if (LANG == "") LANG = "en";  // Default to English
    
    string csvFile = filedir(argv[0]) + "TempLocalizationFile.csv";
    
    // Create a temporary file that will be auto-deleted
    output(csvFile, "wD") {
        printf("");  // Create empty file
    }
    
    string cmd;
    if (IsWindows()) {
        cmd = "powershell -Command \"$ProgressPreference = 'SilentlyContinue'; Invoke-WebRequest -Uri 'https://raw.githubusercontent.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics/main/localization.csv' -TimeoutSec 10 -OutFile '" + csvFile + "'\"";
    } else {
        cmd = "curl -m 10 -s \"https://raw.githubusercontent.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics/main/localization.csv\" > \"" + csvFile + "\"";
    }
    
    if (system(cmd) != 0) {
        return;  // Silently fall back to key names
    }
    
    // Read the CSV file into an array
    string csvLines[];
    int nLines = fileread(csvLines, csvFile);
    
    if (nLines <= 0) {
        return;  // Silently fall back to key names
    }
    
    // Get language column index
    string headers[];
    int nCols = strsplit(headers, csvLines[0], ',');
    int langCol = 1;  // Default to English (column 1)
    int i;
    
    for (i = 0; i < nCols; i++) {
        string header = trim(headers[i]);
        if (header == LANG) {
            langCol = i;
            break;
        }
    }
    
    // Load texts
    for (i = 1; i < nLines; i++) {
        string fields[];
        int n = strsplit(fields, csvLines[i], ',');
        if (n > langCol) {
            string key = trim(fields[0]);
            string value = trim(fields[langCol]);
            addText(key, value);
        }
    }
}

// Function to get context name
string getContextName() {
    switch (currentContext) {
        case CONTEXT_BOARD:
            return "Board";
        case CONTEXT_SCHEMATIC:
            return "Schematic";
        case CONTEXT_PACKAGE:
            return "Footprint";
        case CONTEXT_SYMBOL:
            return "Symbol";
        default:
            return "Unknown";
    }
}

void main(void) {
    // Load localized texts first
    loadLocalizedTexts();
    
    // Get API URL and latest version from versions.csv BEFORE creating the dialog
    string pythonScriptUrl = getApiUrl();
    if (pythonScriptUrl == "") {
        dlgMessageBox("Error: Could not get API URL.\n" +
                     "Using default URL.",
                     "OK");
        pythonScriptUrl = "https://blaisebarrette.pythonanywhere.com/generate-qr";
    }
    
    // Initialize variables
    string Url = "";
    int Size = 500;
    
    // Layer selection (simplified to most commonly used layers)
    string LayerNames[];
    int LayerNumbers[];
    int SelectedLayer = 0;  // Initialize SelectedLayer here
    
    // Detect context and set available layers
    if (board) {
        currentContext = CONTEXT_BOARD;
        LayerNames[0] = "Top";
        LayerNames[1] = "Bottom";
        LayerNames[2] = "SilkscreenTop";
        LayerNames[3] = "SilkscreenBottom";
        LayerNames[4] = "DocumentTop";
        LayerNames[5] = "DocumentBottom";
        LayerNames[6] = "Document";
        LayerNumbers[0] = 1;
        LayerNumbers[1] = 16;
        LayerNumbers[2] = 21;
        LayerNumbers[3] = 22;
        LayerNumbers[4] = 51;
        LayerNumbers[5] = 52;
        LayerNumbers[6] = 48;
    } else if (schematic) {
        currentContext = CONTEXT_SCHEMATIC;
        LayerNames[0] = "Info";
        LayerNames[1] = "Guide";
        LayerNumbers[0] = 97;
        LayerNumbers[1] = 98;
    } else if (library) {
        if (package) {
            currentContext = CONTEXT_PACKAGE;
            LayerNames[0] = "Top";
            LayerNames[1] = "Bottom";
            LayerNames[2] = "SilkscreenTop";
            LayerNames[3] = "SilkscreenBottom";
            LayerNames[4] = "DocumentTop";
            LayerNames[5] = "DocumentBottom";
            LayerNames[6] = "Document";
            LayerNumbers[0] = 1;
            LayerNumbers[1] = 16;
            LayerNumbers[2] = 21;
            LayerNumbers[3] = 22;
            LayerNumbers[4] = 51;
            LayerNumbers[5] = 52;
            LayerNumbers[6] = 48;
        } else if (symbol) {
            currentContext = CONTEXT_SYMBOL;
            LayerNames[0] = "Symbols";
            LayerNames[1] = "Info";
            LayerNames[2] = "Guide";
            LayerNumbers[0] = 94;
            LayerNumbers[1] = 97;
            LayerNumbers[2] = 98;
        } else {
            dlgMessageBox("Error: In Library editor, this ULP must be run from either Footprint or Symbol editor.",
                         "OK");
            exit(1);
        }
    } else {
        dlgMessageBox("Error: This ULP must be run from a valid editor window.\n" +
                     "Supported contexts: Board, Schematic, Footprint, or Symbol",
                     "OK");
        exit(1);
    }
    
    // Dialog for input
    if (!dlgDialog(getText("TITLE")) {
        dlgHBoxLayout {
            dlgVBoxLayout {
                dlgGroup(getText("SETTINGS_GROUP")) {
                    dlgLabel(getText("URL_LABEL"));
                    dlgStringEdit(Url);
                    dlgSpacing(10);
                    dlgLabel(getText("SIZE_LABEL"));
                    dlgSpinBox(Size, 250, 5000);
                    dlgSpacing(10);
                    dlgLabel(getText("LAYER_LABEL"));
                    dlgComboBox(LayerNames, SelectedLayer);
                    dlgSpacing(10);
                    dlgLabel(getText("POSITION_NOTE"));
                }
                dlgSpacing(10);
                dlgHBoxLayout {
                    dlgStretch(1);
                    dlgPushButton("+" + getText("BUTTON_OK")) dlgAccept();
                    dlgPushButton("-" + getText("BUTTON_CANCEL")) dlgReject();
                    dlgStretch(1);
                }
                dlgHBoxLayout {
                    string versionText;
                    if (LATEST_VERSION != "" && LATEST_VERSION != VERSION) {
                        // Older version detected
                        sprintf(versionText, "<font color='gray' size='-1'>v%s</font> <font color='#CC0000' size='-1'>(<a href='https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics/releases/latest'>v%s available</a>)</font>", VERSION, LATEST_VERSION);
                    } else {
                        // Version is up to date
                        sprintf(versionText, "<font color='gray' size='-1'>v%s</font>", VERSION);
                    }
                    dlgLabel(versionText);
                    dlgStretch(1);
                }
            }
        }
    } || Url == "") {
        dlgMessageBox(getText("ERROR_NO_URL"));
        exit(0);
    }
    
    // Prepare file paths
    string tmpFile = filedir(argv[0]) + "qr_temp.txt";
    string scriptFile = filedir(argv[0]) + "qr_script.scr";
    
    // Create temporary files that will be auto-deleted
    output(tmpFile, "wD") {
        printf("");  // Create empty file
    }
    
    // Generate QR code using the retrieved URL
    string cmd;
    if (IsWindows()) {
        cmd = "powershell -Command \"$ProgressPreference = 'SilentlyContinue'; Invoke-WebRequest -Uri '" + pythonScriptUrl + "?url=" + Url + "&size=" + Size + "' -TimeoutSec 10 -OutFile '" + tmpFile + "'\"";
    } else {
        sprintf(cmd, "curl -m 10 -s \"%s?url=%s&size=%d\" > \"%s\"", pythonScriptUrl, Url, Size, tmpFile);
    }
    // Ex√©cuter la commande
    if (system(cmd) != 0) {
        dlgMessageBox("Error: QR Code generation failed\n\n" +
                     "Debug Info:\n" +
                     "- API URL: " + pythonScriptUrl + "\n" +
                     "- Command: " + cmd + "\n" +
                     "Please check your internet connection or try again later.",
                     "OK");
        exit(1);
    }
    
    // Verify QR code response
    if (filesize(tmpFile) <= 0) {
        dlgMessageBox("Error: Empty response from QR Code service\n\n" +
                     "Debug Info:\n" +
                     "- API URL: " + pythonScriptUrl + "\n" +
                     "Please try again later.",
                     "OK");
        exit(1);
    }
    
    // Check response content
    string firstLine;
    if (fileread(firstLine, tmpFile) > 0) {
        if (strstr(firstLine, "Error") >= 0 || strstr(firstLine, "<!DOCTYPE") >= 0) {
            dlgMessageBox("Error: Invalid response from QR Code service\n\n" +
                         "Debug Info:\n" +
                         "- Response: " + firstLine + "\n" +
                         "- API URL: " + pythonScriptUrl + "\n" +
                         "Please try again later.",
                         "OK");
            exit(1);
        }
    }
    
    // Read QR code data
    string lines[];
    int nLines = fileread(lines, tmpFile);
    
    if (nLines <= 0) {
        dlgMessageBox("Error: Could not read QR code data.");
        exit(1);
    }
    
    // Generate Eagle script
    output(scriptFile, "wD") {
        int qrSize = nLines;
        
        // Use the requested size as the base and no longer adjust it
        int targetSize = Size;
        
        // Calculate the module size as a floating-point value (scale factor)
        real moduleScale;
        if ((currentContext == CONTEXT_BOARD) || (currentContext == CONTEXT_PACKAGE)) {
            moduleScale = real(targetSize) / real(qrSize); // For PCB: 1 unit = 1 mil
        } else {
            moduleScale = (real(targetSize) / real(qrSize)) / 1000.0; // For schematic: convert mils to inches
        }
        
        printf("# QR Code Generator Script\n");
        printf("CHANGE LAYER %d;\n", LayerNumbers[SelectedLayer]);
        printf("SET WIRE_BEND 2;\n");
        
        // Creating the rectangles of the QR Code
        int isBottomLayer = (currentContext == CONTEXT_BOARD && 
                           (LayerNumbers[SelectedLayer] == 22 || LayerNumbers[SelectedLayer] == 52)) ||
                           (currentContext == CONTEXT_PACKAGE && 
                           (LayerNumbers[SelectedLayer] == 22 || LayerNumbers[SelectedLayer] == 52));
        
        // Calculate the starting point
        real startX = 0;
        real startY = 0;
        
        if ((currentContext == CONTEXT_BOARD) || (currentContext == CONTEXT_PACKAGE)) {
            if(!isBottomLayer) {
                startX = -(targetSize + 250);
            } else {
                startX = 250;
            }
        } else {
            // For schematics, place at -0.25 inch from origin
            // Convert targetSize from mils to inches and add 0.25 inch
            startX = -(targetSize/1000.0 + 0.5);
        }
        
        for (int row = 0; row < nLines; row++) {
            string line = lines[row];
            for (int col = 0; col < strlen(line); col++) {
                if (line[col] == '1') {
                    // Calculate the positions relative to the starting point
                    real x1f = startX + (real(col) * moduleScale);
                    real y1f = startY + (real(row) * moduleScale);
                    real x2f = x1f + moduleScale;
                    real y2f = y1f + moduleScale;
                    
                    if ((currentContext == CONTEXT_BOARD) || (currentContext == CONTEXT_PACKAGE)) {
                        // For PCB: round to integer
                        int x1 = round(x1f);
                        int y1 = round(y1f);
                        int x2 = round(x2f);
                        int y2 = round(y2f);
                        
                        // Mirror X coordinates if bottom layer
                        if (isBottomLayer) {
                            int temp_x1 = x1;
                            x1 = -x2;
                            x2 = -temp_x1;
                        }
                        
                        printf("RECT (%d %d) (%d %d);\n", x1, y1, x2, y2);
                    } else {
                        // For schematic: keep decimals
                        printf("RECT (%.2f %.2f) (%.2f %.2f);\n", x1f, y1f, x2f, y2f);
                    }
                }
            }
        }
    }
    
    // Execute script and exit
    exit("SCRIPT '" + scriptFile + "'");
} 