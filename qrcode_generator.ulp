// QR Code Generator for Eagle/Fusion Electronics
// This ULP generates QR codes directly on PCB layers
// Version 1.1.1

#usage "en: <b>QR Code Generator for Fusion Electronics</b>\n"
       "<p>"
       "Generate QR codes directly in PCB, Schematic, Symbol, and Footprint contexts with customizable sizes.<br>"
       "The QR code will be automatically placed in the upper-left quadrant from the origin.</p>"
       "<p><b>Usage:</b><br>"
       "1. Run the ULP and enter your URL<br>"
       "2. Select the size (from 250 mils to 5000 mils, where 1000 mils = 1 inch)<br>"
       "3. Choose the destination layer</p>"
       "<p>GitHub: <a href='https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics'>QRCode-ULP-for-Fusion-electronics</a></p>"
       "<author>Author: <b>Blaise Barrette</b></author>",
       
       "fr: <b>Générateur de QR Code pour Fusion Electronics</b>\n"
       "<p>"
       "Générez des QR codes directement dans les contextes PCB, Schéma, Symbole et Encombrement avec des tailles personnalisables.<br>"
       "Le QR code sera automatiquement placé dans le quadrant supérieur gauche à partir de l'origine.</p>"
       "<p><b>Utilisation :</b><br>"
       "1. Exécutez l'ULP et entrez votre URL<br>"
       "2. Sélectionnez la taille (de 250 à 5000 mils, où 1000 mils = 1 pouce)<br>"
       "3. Choisissez la couche de destination</p>"
       "<p>GitHub: <a href='https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics'>QRCode-ULP-for-Fusion-electronics</a></p>"
       "<author>Auteur : <b>Blaise Barrette</b></author>",
       
       "de: <b>QR-Code-Generator für Fusion Electronics</b>\n"
       "<p>"
       "Generieren Sie QR-Codes direkt in PCB-, Schaltplan-, Symbol- und Footprint-Kontexten mit anpassbaren Größen.<br>"
       "Der QR-Code wird automatisch im oberen linken Quadranten vom Ursprung platziert.</p>"
       "<p><b>Verwendung:</b><br>"
       "1. Führen Sie das ULP aus und geben Sie Ihre URL ein<br>"
       "2. Wählen Sie die Größe (von 250 bis 5000 mils, wobei 1000 mils = 1 Zoll)<br>"
       "3. Wählen Sie die Zielebene</p>"
       "<p>GitHub: <a href='https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics'>QRCode-ULP-for-Fusion-electronics</a></p>"
       "<author>Autor: <b>Blaise Barrette</b></author>",
       
       "es: <b>Generador de códigos QR para Fusion Electronics</b>\n"
       "<p>"
       "Genere códigos QR directamente en contextos de PCB, Esquemático, Símbolo y Huella con tamaños personalizables.<br>"
       "El código QR se colocará automáticamente en el cuadrante superior izquierdo desde el origen.</p>"
       "<p><b>Uso:</b><br>"
       "1. Ejecute el ULP e ingrese su URL<br>"
       "2. Seleccione el tamaño (de 250 a 5000 mils, donde 1000 mils = 1 pulgada)<br>"
       "3. Elija la capa de destino</p>"
       "<p>GitHub: <a href='https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics'>QRCode-ULP-for-Fusion-electronics</a></p>"
       "<author>Autor: <b>Blaise Barrette</b></author>",
       
       "it: <b>Generatore di codici QR per Fusion Electronics</b>\n"
       "<p>"
       "Genera codici QR direttamente nei contesti PCB, Schema, Simbolo e Impronta con dimensioni personalizzabili.<br>"
       "Il codice QR verrà posizionato automaticamente nel quadrante superiore sinistro dall'origine.</p>"
       "<p><b>Utilizzo:</b><br>"
       "1. Esegui l'ULP e inserisci il tuo URL<br>"
       "2. Seleziona la dimensione (da 250 a 5000 mils, dove 1000 mils = 1 pollice)<br>"
       "3. Scegli il layer di destinazione</p>"
       "<p>GitHub: <a href='https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics'>QRCode-ULP-for-Fusion-electronics</a></p>"
       "<author>Autore: <b>Blaise Barrette</b></author>",
       
       "ja: <b>QRコードジェネレーター for Fusion Electronics</b>\n"
       "<p>"
       "PCB、回路図、シンボル、フットプリントのコンテキストで、カスタマイズ可能なサイズのQRコードを直接生成します。<br>"
       "QRコードは原点から左上の象限に自動的に配置されます。</p>"
       "<p><b>使用方法：</b><br>"
       "1. ULPを実行してURLを入力<br>"
       "2. サイズを選択（250～5000 mils、1000 mils = 1インチ）<br>"
       "3. 配置するレイヤーを選択</p>"
       "<p>GitHub: <a href='https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics'>QRCode-ULP-for-Fusion-electronics</a></p>"
       "<author>作者: <b>Blaise Barrette</b></author>",
       
       "ko: <b>QR 코드 생성기 for Fusion Electronics</b>\n"
       "<p>"
       "PCB, 회로도, 심볼, 풋프린트 컨텍스트에서 사용자 지정 크기로 QR 코드를 직접 생성합니다.<br>"
       "QR 코드는 원점에서 좌측 상단 사분면에 자동으로 배치됩니다.</p>"
       "<p><b>사용법:</b><br>"
       "1. ULP를 실행하고 URL 입력<br>"
       "2. 크기 선택 (250~5000 mils, 1000 mils = 1인치)<br>"
       "3. 대상 레이어 선택</p>"
       "<p>GitHub: <a href='https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics'>QRCode-ULP-for-Fusion-electronics</a></p>"
       "<author>작성자: <b>Blaise Barrette</b></author>",
       
       "pl: <b>Generator kodów QR dla Fusion Electronics</b>\n"
       "<p>"
       "Generuj kody QR bezpośrednio w kontekstach PCB, Schematu, Symbolu i Footprintu z dostosowywanymi rozmiarami.<br>"
       "Kod QR zostanie automatycznie umieszczony w lewym górnym kwadrancie od początku układu.</p>"
       "<p><b>Użycie:</b><br>"
       "1. Uruchom ULP i wprowadź swój URL<br>"
       "2. Wybierz rozmiar (od 250 do 5000 mils, gdzie 1000 mils = 1 cal)<br>"
       "3. Wybierz warstwę docelową</p>"
       "<p>GitHub: <a href='https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics'>QRCode-ULP-for-Fusion-electronics</a></p>"
       "<author>Autor: <b>Blaise Barrette</b></author>",
       
       "pt: <b>Gerador de código QR para Fusion Electronics</b>\n"
       "<p>"
       "Gere códigos QR diretamente nos contextos de PCB, Esquemático, Símbolo e Footprint com tamanhos personalizáveis.<br>"
       "O código QR será automaticamente colocado no quadrante superior esquerdo a partir da origem.</p>"
       "<p><b>Uso:</b><br>"
       "1. Execute o ULP e insira sua URL<br>"
       "2. Selecione o tamanho (de 250 a 5000 mils, onde 1000 mils = 1 polegada)<br>"
       "3. Escolha a camada de destino</p>"
       "<p>GitHub: <a href='https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics'>QRCode-ULP-for-Fusion-electronics</a></p>"
       "<author>Autor: <b>Blaise Barrette</b></author>",
       
       "zh: <b>二维码生成器 for Fusion Electronics</b>\n"
       "<p>"
       "在PCB、原理图、符号和封装环境中直接生成可自定义大小的二维码。<br>"
       "二维码将自动放置在原点的左上象限。</p>"
       "<p><b>使用方法：</b><br>"
       "1. 运行ULP并输入URL<br>"
       "2. 选择大小（250至5000 mils，其中1000 mils = 1英寸）<br>"
       "3. 选择目标层</p>"
       "<p>GitHub: <a href='https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics'>QRCode-ULP-for-Fusion-electronics</a></p>"
       "<author>作者: <b>Blaise Barrette</b></author>",
       
       "tr: <b>QR Kod Üreteci for Fusion Electronics</b>\n"
       "<p>"
       "PCB, Şematik, Sembol ve Footprint bağlamlarında özelleştirilebilir boyutlarla doğrudan QR kodları oluşturun.<br>"
       "QR kodu otomatik olarak başlangıç noktasından sol üst kadrana yerleştirilecektir.</p>"
       "<p><b>Kullanım:</b><br>"
       "1. ULP'yi çalıştırın ve URL'nizi girin<br>"
       "2. Boyutu seçin (250 ile 5000 mil arası, 1000 mil = 1 inç)<br>"
       "3. Hedef katmanı seçin</p>"
       "<p>GitHub: <a href='https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics'>QRCode-ULP-for-Fusion-electronics</a></p>"
       "<author>Yazar: <b>Blaise Barrette</b></author>"

#require 4.11  // 4.11 is the minimum Eagle version required for this ULP

// Global variables
string VERSION = "1.1.1";
string LATEST_VERSION = "";
int PosX, PosY;
string LANG;  // Current language code
string debugGridInfo = "";  // Déplacer ici et supprimer la déclaration plus bas

// Context constants and variable
enum {
    CONTEXT_BOARD,
    CONTEXT_SCHEMATIC,
    CONTEXT_PACKAGE,
    CONTEXT_SYMBOL
};
int currentContext;

// Arrays for localization
string TextKeys[];    // Store keys
string TextValues[];  // Store corresponding values
int TextCount = 0;    // Number of texts loaded

// After the global variables section, add these constants and variables
enum {
    UNIT_MILS,
    UNIT_INCHES,
    UNIT_MM
};

int currentUnit = UNIT_MILS;  // Default to mils
string UnitNames[] = {"mils", "inches", "mm"};

// Function to get grid unit text
string getGridUnitText(int displayUnit) {
    switch(displayUnit) {
        case 0: return "MICRON";  // GRID_UNIT_MIC
        case 1: return "MM";      // GRID_UNIT_MM
        case 2: return "MIL";     // GRID_UNIT_MIL
        case 3: return "INCH";    // GRID_UNIT_INCH
        default: return "UNKNOWN";
    }
}

// Function to get default grid unit and scale
int getDefaultGridUnit() {
    if (board) {
        board(B) {
            // Get both display unit and actual grid unit
            int displayUnit = B.grid.unit;
            real gridDist = B.grid.distance;
            
            // Store grid info for debug
            sprintf(debugGridInfo, "Grid Unit: %s, Distance: %.6f", 
                    getGridUnitText(displayUnit), gridDist);
            
            // Map EAGLE grid units to our units
            switch(displayUnit) {
                case 0:  // GRID_UNIT_MIC
                    return UNIT_MM;
                case 1:  // GRID_UNIT_MM
                    return UNIT_MM;
                case 2:  // GRID_UNIT_MIL
                    return UNIT_MILS;
                case 3:  // GRID_UNIT_INCH
                    return UNIT_INCHES;
            }
        }
    } else if (library) {
        library(L) {
            int displayUnit = L.grid.unit;
            real gridDist = L.grid.distance;
            
            sprintf(debugGridInfo, "Grid Unit: %s, Distance: %.6f", 
                    getGridUnitText(displayUnit), gridDist);
            
            switch(displayUnit) {
                case 0:  // GRID_UNIT_MIC
                    return UNIT_MM;
                case 1:  // GRID_UNIT_MM
                    return UNIT_MM;
                case 2:  // GRID_UNIT_MIL
                    return UNIT_MILS;
                case 3:  // GRID_UNIT_INCH
                    return UNIT_INCHES;
            }
        }
    } else if (schematic) {
        schematic(S) {
            int displayUnit = S.grid.unit;
            real gridDist = S.grid.distance;
            
            sprintf(debugGridInfo, "Grid Unit: %s, Distance: %.6f", 
                    getGridUnitText(displayUnit), gridDist);
            
            switch(displayUnit) {
                case 0:  // GRID_UNIT_MIC
                    return UNIT_MM;
                case 1:  // GRID_UNIT_MM
                    return UNIT_MM;
                case 2:  // GRID_UNIT_MIL
                    return UNIT_MILS;
                case 3:  // GRID_UNIT_INCH
                    return UNIT_INCHES;
            }
        }
    }
    return UNIT_MILS;
}

// Function to convert size to mils based on selected unit
int convertToMils(real size, int fromUnit) {
    switch(fromUnit) {
        case UNIT_MM:
            return round(size * 39.3701);  // mm to mils (1 mm = 39.3701 mils)
        case UNIT_INCHES:
            return round(size * 1000.0);   // inches to mils (1 inch = 1000 mils)
        case UNIT_MILS:
            return round(size);
    }
    return round(size);
}

// Function to convert size from mils to selected unit
real convertFromMils(int size, int toUnit) {
    switch(toUnit) {
        case UNIT_MM:
            return real(size) / 39.3701;   // mils to mm
        case UNIT_INCHES:
            return real(size) / 1000.0;    // mils to inches
        case UNIT_MILS:
            return real(size);
    }
    return real(size);
}

// Function to detect Windows OS
int IsWindows() {
    //Returns 1, if EAGLE is running under Windows (0 for Linux/Mac)
    if ((strsub(argv[0],0,1)=="/") && (strsub(argv[0],0,2)!="//"))
        return 0;
    return 1;
}

// Function to get localized text by key
string getText(string key) {
    for (int i = 0; i < TextCount; i++) {
        if (TextKeys[i] == key) {
            return TextValues[i];
        }
    }
    return key;  // Return key if text not found
}

// Function to add text to arrays
void addText(string key, string value) {
    TextKeys[TextCount] = key;
    TextValues[TextCount] = value;
    TextCount++;
}

// Function to get API URL for current version
string getApiUrl() {
    string csvFile = filedir(argv[0]) + "TempVersionsFile.csv";
    
    // Create a temporary file that will be auto-deleted
    output(csvFile, "wD") {
        printf("");  // Create empty file
    }
    
    string cmd;
    if (IsWindows()) {
        // Create a temporary VBS script
        string vbsFile = filedir(argv[0]) + "temp_version_check.vbs";
        output(vbsFile, "wD") {
            printf("Set http = CreateObject(\"Microsoft.XMLHTTP\")\n");
            printf("http.open \"GET\", \"https://raw.githubusercontent.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics/main/versions.csv\", False\n");
            printf("http.send\n");
            printf("If http.Status = 200 Then\n");
            printf("    Set fso = CreateObject(\"Scripting.FileSystemObject\")\n");
            printf("    Set file = fso.CreateTextFile(\"%s\", True)\n", csvFile);
            printf("    file.Write(http.responseText)\n");
            printf("    file.Close\n");
            printf("End If\n");
            printf("Set http = Nothing\n");
        }
        cmd = "wscript \"" + vbsFile + "\"";
    } else {
        cmd = "curl -m 10 -s \"https://raw.githubusercontent.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics/main/versions.csv\" > \"" + csvFile + "\"";
    }
    
    int exitCode = system(cmd);
    int i;
    
    if (exitCode != 0) {
        dlgMessageBox(getText("ERROR_NETWORK") + "\n\n" +
                     getText("DEBUG_INFO") + "\n" +
                     "- Exit Code: " + exitCode + "\n" +
                     "- Command: " + cmd + "\n" +
                     "- ULP Version: " + VERSION + "\n\n" +
                     "Please check your internet connection.",
                     getText("BUTTON_OK"));
        return "";
    }
    
    // Read the CSV file into an array
    string csvLines[];
    int nLines = fileread(csvLines, csvFile);
    
    if (nLines <= 1) {  // File must have at least 2 lines (header + data)
        return "";
    }
    
    // Find the latest version available (first line after header)
    if (nLines > 1) {
        string fields[];
        int n = strsplit(fields, csvLines[1], ',');
        if (n >= 4) {
            LATEST_VERSION = fields[0];  // First version is the most recent
        }
    }
    
    string api_url = "";  // Variable to store the API URL
    
    // Loop through lines to find current version
    for (i = 1; i < nLines; i++) {
        string fields[];
        int n = strsplit(fields, csvLines[i], ',');
        if (n >= 4 && fields[0] == VERSION) {
            // Check if version is supported
            if (n >= 5 && fields[4] == "0") {
                dlgMessageBox("Error: This version of the ULP is no longer supported.\n\n" +
                            "Debug Info:\n" +
                            "- ULP Version: " + VERSION + "\n" +
                            "- CSV Line: " + csvLines[i] + "\n\n" +
                            "Please download the latest version to continue:\n" +
                            "https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics/releases/latest",
                            "OK");
                exit(1);
            }
            api_url = fields[3];  // Store the API URL
            break;
        }
    }
    
    return api_url;  // Return the API URL
}

// Function to trim whitespace from string
string trim(string str) {
    string result = "";
    int start = 0;
    int end = strlen(str) - 1;
    
    // Find first non-space character
    while (start < strlen(str)) {
        if (strsub(str, start, 1) != " ") break;
        start++;
    }
    
    // Find last non-space character
    while (end >= 0) {
        if (strsub(str, end, 1) != " ") break;
        end--;
    }
    
    // Extract the trimmed string
    if (start <= end) {
        result = strsub(str, start, end - start + 1);
    }
    
    return result;
}

// Function to load localized texts
void loadLocalizedTexts() {
    LANG = language();
    if (LANG == "") LANG = "en";  // Default to English
    
    string csvFile = filedir(argv[0]) + "TempLocalizationFile.csv";
    
    // Create a temporary file that will be auto-deleted
    output(csvFile, "wD") {
        printf("");  // Create empty file
    }
    
    string cmd;
    if (IsWindows()) {
        // Create a temporary VBS script
        string vbsFile = filedir(argv[0]) + "temp_localization.vbs";
        output(vbsFile, "wD") {
            printf("Option Explicit\n");
            printf("Dim http, stream, fso, file\n");
            printf("Set http = CreateObject(\"MSXML2.XMLHTTP\")\n");  // Using MSXML2.XMLHTTP instead of Microsoft.XMLHTTP
            printf("http.open \"GET\", \"https://raw.githubusercontent.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics/main/localization.csv\", False\n");
            printf("http.send\n");
            printf("If http.Status = 200 Then\n");
            printf("    Set stream = CreateObject(\"ADODB.Stream\")\n");
            printf("    stream.Open\n");
            printf("    stream.Type = 2  'Text\n");
            printf("    stream.Charset = \"UTF-8\"\n");
            printf("    stream.WriteText http.responseText\n");
            printf("    stream.SaveToFile \"%s\", 2\n", csvFile);
            printf("    stream.Close\n");
            printf("End If\n");
            printf("Set http = Nothing\n");
        }
        cmd = "wscript \"" + vbsFile + "\"";
    } else {
        cmd = "curl -m 10 -s \"https://raw.githubusercontent.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics/main/localization.csv\" > \"" + csvFile + "\"";
    }
    
    if (system(cmd) != 0) {
        return;  // Silently fall back to key names
    }
    
    // Read the CSV file into an array
    string csvLines[];
    int nLines = fileread(csvLines, csvFile);
    
    if (nLines <= 0) {
        return;  // Silently fall back to key names
    }
    
    // Get language column index
    string headers[];
    int nCols = strsplit(headers, csvLines[0], ',');
    int langCol = 1;  // Default to English (column 1)
    int i;
    
    for (i = 0; i < nCols; i++) {
        string header = trim(headers[i]);
        if (header == LANG) {
            langCol = i;
            break;
        }
    }
    
    // Load texts
    for (i = 1; i < nLines; i++) {
        string fields[];
        int n = strsplit(fields, csvLines[i], ',');
        if (n > langCol) {
            string key = trim(fields[0]);
            string value = trim(fields[langCol]);
            addText(key, value);
        }
    }
}

// Function to get context name
string getContextName() {
    switch (currentContext) {
        case CONTEXT_BOARD:
            return "Board";
        case CONTEXT_SCHEMATIC:
            return "Schematic";
        case CONTEXT_PACKAGE:
            return "Footprint";
        case CONTEXT_SYMBOL:
            return "Symbol";
        default:
            return "Unknown";
    }
}

// Function to show help dialog
void showHelpDialog() {
    dlgDialog("Help") {
        dlgVBoxLayout {
            dlgTextView(usage);
            dlgHBoxLayout {
                dlgStretch(1);
                dlgPushButton(getText("BUTTON_OK")) dlgAccept();
                dlgStretch(1);
            }
        }
    };
}

void main(void) {
    // Load localized texts first
    loadLocalizedTexts();
    
    // Get API URL and latest version from versions.csv BEFORE creating the dialog
    string pythonScriptUrl = getApiUrl();
    if (pythonScriptUrl == "") {
        dlgMessageBox("Error: Could not get API URL.\n" +
                     "Using default URL.",
                     "OK");
        pythonScriptUrl = "https://blaisebarrette.pythonanywhere.com/generate-qr";
    }
    
    // Initialize variables
    string Url = "";
    int Size = 500;  // Size in mils
    currentUnit = getDefaultGridUnit();  // Set initial unit based on grid preferences
    real displaySize = convertFromMils(Size, currentUnit);  // Convert for display
    
    // Layer selection (simplified to most commonly used layers)
    string LayerNames[];
    int LayerNumbers[];
    int SelectedLayer = 0;  // Initialize SelectedLayer here
    
    // Detect context and set available layers
    if (board) {
        currentContext = CONTEXT_BOARD;
        LayerNames[0] = "Top";
        LayerNames[1] = "Bottom";
        LayerNames[2] = "SilkscreenTop";
        LayerNames[3] = "SilkscreenBottom";
        LayerNames[4] = "DocumentTop";
        LayerNames[5] = "DocumentBottom";
        LayerNames[6] = "Document";
        LayerNumbers[0] = 1;
        LayerNumbers[1] = 16;
        LayerNumbers[2] = 21;
        LayerNumbers[3] = 22;
        LayerNumbers[4] = 51;
        LayerNumbers[5] = 52;
        LayerNumbers[6] = 48;
    } else if (schematic) {
        currentContext = CONTEXT_SCHEMATIC;
        LayerNames[0] = "Info";
        LayerNames[1] = "Guide";
        LayerNumbers[0] = 97;
        LayerNumbers[1] = 98;
    } else if (library) {
        if (package) {
            currentContext = CONTEXT_PACKAGE;
            LayerNames[0] = "Top";
            LayerNames[1] = "Bottom";
            LayerNames[2] = "SilkscreenTop";
            LayerNames[3] = "SilkscreenBottom";
            LayerNames[4] = "DocumentTop";
            LayerNames[5] = "DocumentBottom";
            LayerNames[6] = "Document";
            LayerNumbers[0] = 1;
            LayerNumbers[1] = 16;
            LayerNumbers[2] = 21;
            LayerNumbers[3] = 22;
            LayerNumbers[4] = 51;
            LayerNumbers[5] = 52;
            LayerNumbers[6] = 48;
        } else if (symbol) {
            currentContext = CONTEXT_SYMBOL;
            LayerNames[0] = "Symbols";
            LayerNames[1] = "Info";
            LayerNames[2] = "Guide";
            LayerNumbers[0] = 94;
            LayerNumbers[1] = 97;
            LayerNumbers[2] = 98;
        } else {
            dlgMessageBox("Error: In Library editor, this ULP must be run from either Footprint or Symbol editor.",
                         "OK");
            exit(1);
        }
    } else {
        dlgMessageBox("Error: This ULP must be run from a valid editor window.\n" +
                     "Supported contexts: Board, Schematic, Footprint, or Symbol",
                     "OK");
        exit(1);
    }
    
    // Dialog for input
    if (!dlgDialog(getText("TITLE")) {
        dlgHBoxLayout {
            dlgVBoxLayout {
                dlgGroup(getText("SETTINGS_GROUP")) {
                    dlgLabel(getText("URL_LABEL"));
                    dlgStringEdit(Url);
                    dlgSpacing(10);
                    dlgLabel(getText("SIZE_LABEL"));
                    dlgHBoxLayout {
                        dlgRealEdit(displaySize, 0.25, 5000.0);
                        dlgComboBox(UnitNames, currentUnit) {
                            // Convert displayed size when unit changes
                            int tempMils = convertToMils(displaySize, currentUnit);  // Convert current size to mils
                            displaySize = convertFromMils(tempMils, currentUnit);  // Convert back to new unit
                            dlgRedisplay();
                        }
                    }
                    dlgSpacing(10);
                    dlgLabel(getText("LAYER_LABEL"));
                    dlgComboBox(LayerNames, SelectedLayer);
                    dlgSpacing(10);
                    dlgLabel(getText("POSITION_NOTE"));
                }
                dlgSpacing(10);
                dlgHBoxLayout {
                    dlgStretch(1);
                    dlgPushButton("+" + getText("BUTTON_OK")) dlgAccept();
                    dlgPushButton("-" + getText("BUTTON_CANCEL")) dlgReject();
                    dlgStretch(1);
                }
                dlgHBoxLayout {
                    string versionText;
                    if (LATEST_VERSION != "" && LATEST_VERSION != VERSION) {
                        // Older version detected
                        sprintf(versionText, "v%s (%s available)", VERSION, LATEST_VERSION);
                    } else {
                        // Version is up to date
                        sprintf(versionText, "v%s", VERSION);
                    }
                    dlgLabel(versionText);
                    dlgStretch(1);
                    dlgPushButton("?") {
                        showHelpDialog();
                    }
                }
            }
        }
    } || Url == "") {
        dlgMessageBox(getText("ERROR_NO_URL"));
        exit(0);
    }
    
    // Convert final size to mils for QR code generation
    Size = convertToMils(displaySize, currentUnit);
    
    // Debug dialog
    int displayUnit = 0;  // Default to MICRON
    if (board) {
        board(B) displayUnit = B.grid.unit;
    } else if (library) {
        library(L) displayUnit = L.grid.unit;
    } else if (schematic) {
        schematic(S) displayUnit = S.grid.unit;
    }

    string debugInfo;
    sprintf(debugInfo, 
        "Debug Information:\n\n"
        "Grid Unit: %s\n"
        "Selected Unit: %s\n"
        "Input Size: %.3f %s\n"
        "Test Conversions:\n"
        "- 1000 mils = %.3f mm\n"
        "- 25.4 mm = %d mils\n"
        "- 1 inch = %d mils\n"
        "Final Size (mils): %d\n"
        "Context: %s",
        getGridUnitText(displayUnit),  // Grid unit
        UnitNames[currentUnit],        // Selected unit in dialog
        displaySize, UnitNames[currentUnit],
        convertFromMils(1000, UNIT_MM),
        convertToMils(25.4, UNIT_MM),
        convertToMils(1.0, UNIT_INCHES),
        Size,
        getContextName()
    );

    dlgMessageBox(debugInfo, "OK");
    
    // Prepare file paths
    string tmpFile = filedir(argv[0]) + "qr_temp.txt";
    string scriptFile = filedir(argv[0]) + "qr_script.scr";
    
    // Create temporary files that will be auto-deleted
    output(tmpFile, "wD") {
        printf("");  // Create empty file
    }
    
    // Generate QR code using the retrieved URL
    string cmd;
    if (IsWindows()) {
        // Create a temporary VBS script
        string vbsFile = filedir(argv[0]) + "temp_request.vbs";
        output(vbsFile, "wD") {
            printf("Set http = CreateObject(\"Microsoft.XMLHTTP\")\n");
            printf("http.open \"GET\", \"%s?url=%s&size=%d\", False\n", pythonScriptUrl, Url, Size);
            printf("http.send\n");
            printf("If http.Status = 200 Then\n");
            printf("    Set fso = CreateObject(\"Scripting.FileSystemObject\")\n");
            printf("    Set file = fso.CreateTextFile(\"%s\", True)\n", tmpFile);
            printf("    file.Write(http.responseText)\n");
            printf("    file.Close\n");
            printf("End If\n");
            printf("Set http = Nothing\n");
        }
        cmd = "wscript \"" + vbsFile + "\"";
    } else {
        sprintf(cmd, "curl -m 10 -s \"%s?url=%s&size=%d\" > \"%s\"", pythonScriptUrl, Url, Size, tmpFile);
    }
    // Exécuter la commande
    if (system(cmd) != 0) {
        dlgMessageBox("Error: QR Code generation failed\n\n" +
                     "Debug Info:\n" +
                     "- API URL: " + pythonScriptUrl + "\n" +
                     "- Command: " + cmd + "\n" +
                     "Please check your internet connection or try again later.",
                     "OK");
        exit(1);
    }
    
    // Verify QR code response
    if (filesize(tmpFile) <= 0) {
        dlgMessageBox("Error: Empty response from QR Code service\n\n" +
                     "Debug Info:\n" +
                     "- API URL: " + pythonScriptUrl + "\n" +
                     "Please try again later.",
                     "OK");
        exit(1);
    }
    
    // Check response content
    string firstLine;
    if (fileread(firstLine, tmpFile) > 0) {
        if (strstr(firstLine, "Error") >= 0 || strstr(firstLine, "<!DOCTYPE") >= 0) {
            dlgMessageBox("Error: Invalid response from QR Code service\n\n" +
                         "Debug Info:\n" +
                         "- Response: " + firstLine + "\n" +
                         "- API URL: " + pythonScriptUrl + "\n" +
                         "Please try again later.",
                         "OK");
            exit(1);
        }
    }
    
    // Read QR code data
    string lines[];
    int nLines = fileread(lines, tmpFile);
    
    if (nLines <= 0) {
        dlgMessageBox("Error: Could not read QR code data.");
        exit(1);
    }
    
    // Generate Eagle script
    output(scriptFile, "wD") {
        int qrSize = nLines;
        
        // Use the requested size as the base and no longer adjust it
        int targetSize = Size;
        
        // Calculate the module size as a floating-point value (scale factor)
        real moduleScale;
        if ((currentContext == CONTEXT_BOARD) || (currentContext == CONTEXT_PACKAGE)) {
            moduleScale = real(targetSize) / real(qrSize); // For PCB: 1 unit = 1 mil
        } else {
            moduleScale = (real(targetSize) / real(qrSize)) / 1000.0; // For schematic: convert mils to inches
        }
        
        printf("# QR Code Generator Script\n");
        printf("CHANGE LAYER %d;\n", LayerNumbers[SelectedLayer]);
        printf("SET WIRE_BEND 2;\n");
        
        // Creating the rectangles of the QR Code
        int isBottomLayer = (currentContext == CONTEXT_BOARD && 
                           (LayerNumbers[SelectedLayer] == 22 || LayerNumbers[SelectedLayer] == 52)) ||
                           (currentContext == CONTEXT_PACKAGE && 
                           (LayerNumbers[SelectedLayer] == 22 || LayerNumbers[SelectedLayer] == 52));
        
        // Calculate the starting point
        real startX = 0;
        real startY = 0;
        
        if ((currentContext == CONTEXT_BOARD) || (currentContext == CONTEXT_PACKAGE)) {
            if(!isBottomLayer) {
                startX = -(targetSize + 250);
            } else {
                startX = 250;
            }
        } else {
            // For schematics, place at -0.25 inch from origin
            // Convert targetSize from mils to inches and add 0.25 inch
            startX = -(targetSize/1000.0 + 0.5);
        }
        
        for (int row = 0; row < nLines; row++) {
            string line = lines[row];
            for (int col = 0; col < strlen(line); col++) {
                if (line[col] == '1') {
                    // Calculate the positions relative to the starting point
                    real x1f = startX + (real(col) * moduleScale);
                    real y1f = startY + (real(row) * moduleScale);
                    real x2f = x1f + moduleScale;
                    real y2f = y1f + moduleScale;
                    
                    if ((currentContext == CONTEXT_BOARD) || (currentContext == CONTEXT_PACKAGE)) {
                        // For PCB: round to integer
                        int x1 = round(x1f);
                        int y1 = round(y1f);
                        int x2 = round(x2f);
                        int y2 = round(y2f);
                        
                        // Mirror X coordinates if bottom layer
                        if (isBottomLayer) {
                            int temp_x1 = x1;
                            x1 = -x2;
                            x2 = -temp_x1;
                        }
                        
                        printf("RECT (%d %d) (%d %d);\n", x1, y1, x2, y2);
                    } else {
                        // For schematic: keep decimals
                        printf("RECT (%.2f %.2f) (%.2f %.2f);\n", x1f, y1f, x2f, y2f);
                    }
                }
            }
        }
    }
    
    // Execute script and exit
    exit("SCRIPT '" + scriptFile + "'");
} 