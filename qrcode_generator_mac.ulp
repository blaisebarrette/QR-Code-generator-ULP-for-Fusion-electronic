// QR Code Generator for Eagle/Fusion Electronics
// Version 1.0.0

#usage "<b>QR Code Generator for MacOS</b>\n"
       "<p>"
       "Generate QR codes directly on PCB layers with customizable size and position.<br>"
       "This ULP allows you to create QR codes that can be placed on any PCB layer "
       "in your Fusion Electronics design."
       "</p>"
       "<p>"
       "<b>Usage:</b><br>"
       "Run the ULP and specify URL, layer, and size. The QR code will be generated "
       "and placed at the specified coordinates."
       "</p>"
       "<p>"
       "<b>Note:</b> This version is for MacOS only.<br>"
       "For Windows version, visit: "
       "<a href='https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics'>GitHub Repository</a>"
       "</p>"
       "<author>Author: <b>Blaise Barrette</b></author>"

#require 4.11

// Global variables
string VERSION = "1.0.0";
int PosX, PosY;

// Function to parse JSON string
string getJsonValue(string json, string key) {
    string searchKey = "\"" + key + "\"";
    int pos = strstr(json, searchKey);
    if (pos >= 0) {
        // Find the first ":" after the key
        pos = strstr(json, ":", pos);
        if (pos >= 0) {
            // Find the opening quote
            pos = strstr(json, "\"", pos);
            if (pos >= 0) {
                pos++; // Skip the opening quote
                // Find the closing quote
                int endPos = strstr(json, "\"", pos);
                if (endPos >= 0) {
                    return strsub(json, pos, endPos - pos);
                }
            }
        }
    }
    return "";
}

// Function to find version info in JSON
string findVersionInfo(string json, string version) {
    string searchVer = "\"version\":\"" + version + "\"";
    int pos = strstr(json, searchVer);
    if (pos >= 0) {
        // Reculer pour trouver le début de l'objet
        int startPos = pos;
        while (startPos > 0 && json[startPos] != '{') {
            startPos--;
        }
        // Avancer pour trouver la fin de l'objet
        int endPos = pos;
        int braceCount = 1;
        while (endPos < strlen(json) && braceCount > 0) {
            endPos++;
            if (json[endPos] == '{') braceCount++;
            if (json[endPos] == '}') braceCount--;
        }
        if (braceCount == 0) {
            return strsub(json, startPos, endPos - startPos + 1);
        }
    }
    return "";
}

// Function to check if version is supported
int isVersionSupported(string versionInfo) {
    return (strstr(versionInfo, "\"supported\":true") >= 0);
}

// Function to get script URL from version info
string getScriptUrl(string versionInfo) {
    int urlStart = strstr(versionInfo, "\"url\":\"");
    if (urlStart >= 0) {
        urlStart += 7; // Skip "url":""
        int urlEnd = strstr(versionInfo, "\"", urlStart);
        if (urlEnd >= 0) {
            return strsub(versionInfo, urlStart, urlEnd - urlStart);
        }
    }
    return "";
}

// Function to check for updates
void checkForUpdates() {
    string tmpFile = filedir(argv[0]) + "version_check.txt";
    string curlCmd = "curl -m 10 -s \"https://raw.githubusercontent.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics/main/version.json\" > \"" + tmpFile + "\"";
    
    if (system(curlCmd) != 0) {
        dlgMessageBox("Debug: Failed to fetch version info\n" +
                     "ULP Version: " + VERSION + "\n" +
                     "Command: " + curlCmd,
                     "OK");
        return;
    }
    
    string versionData[];
    int nLines = fileread(versionData, tmpFile);
    if (nLines <= 0) {
        dlgMessageBox("Debug: Empty version file\n" +
                     "ULP Version: " + VERSION + "\n" +
                     "File: " + tmpFile,
                     "OK");
        system("rm \"" + tmpFile + "\"");
        return;
    }
    
    string jsonData = strjoin(versionData, '\n');
    string latestVersion = getJsonValue(jsonData, "latest_version");
    string versionInfo = findVersionInfo(jsonData, VERSION);
    int supported = isVersionSupported(versionInfo);
    
    // Check if current version is supported
    if (!supported) {
        dlgMessageBox("Error: This version of the ULP is no longer supported.\n\n" +
                     "Debug Info:\n" +
                     "- ULP Version: " + VERSION + "\n" +
                     "- Latest Version: " + latestVersion + "\n" +
                     "- Version Info Found: " + (versionInfo != "" ? "Yes" : "No") + "\n" +
                     "- JSON Data: " + jsonData + "\n\n" +
                     "Please download the latest version to continue:\n" +
                     "https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics/releases/latest",
                     "OK");
        exit(1);
    }
    
    // Check for newer version
    if (latestVersion != VERSION) {
        dlgMessageBox("A new version is available (v" + latestVersion + ")!\n\n" +
                     "Download the update here:\n" +
                     "https://github.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics/releases/latest",
                     "Continue");
    }
    
    system("rm \"" + tmpFile + "\"");
}

// Function to calculate default position based on size
void updateDefaultPosition(int size) {
    PosX = -(size + 1000);
    PosY = -(size + 1000);
}

void main(void) {
    // Check for updates first
    checkForUpdates();
    
    // Initialize variables
    string Url = "";
    int Size = 500;
    
    // Layer selection (simplified to most commonly used layers)
    string LayerNames[] = {
        "Top Silkscreen (tPlace)",
        "Bottom Silkscreen (bPlace)",
        "Top Documentation (tDocu)",
        "Bottom Documentation (bDocu)"
    };
    int LayerNumbers[] = {21, 22, 51, 52};
    int SelectedLayer = 0;
    
    // Initialize default positions
    updateDefaultPosition(Size);
    
    // Dialog for input
    if (!dlgDialog("QR Code Generator") {
        dlgHBoxLayout {
            dlgVBoxLayout {
                dlgGroup("QR Code Settings") {
                    dlgLabel("Enter the URL for your QR code:");
                    dlgStringEdit(Url);
                    dlgSpacing(10);
                    dlgLabel("Enter size in mils (250-5000):");
                    dlgHBoxLayout {
                        dlgSpinBox(Size, 250, 5000);
                        dlgPushButton("Update Position") {
                            updateDefaultPosition(Size);
                            dlgRedisplay();
                        }
                    }
                    dlgSpacing(10);
                    dlgLabel("Select layer:");
                    dlgComboBox(LayerNames, SelectedLayer);
                    dlgSpacing(10);
                    dlgGroup("Position (mils)") {
                        dlgHBoxLayout {
                            dlgLabel("X:");
                            dlgSpinBox(PosX, -50000, 50000);
                            dlgLabel("Y:");
                            dlgSpinBox(PosY, -50000, 50000);
                        }
                    }
                }
                dlgSpacing(10);
                dlgHBoxLayout {
                    dlgStretch(1);
                    dlgPushButton("+OK") dlgAccept();
                    dlgPushButton("-Cancel") dlgReject();
                    dlgStretch(1);
                }
            }
        }
    } || Url == "") {
        dlgMessageBox("No URL provided. Operation cancelled.");
        exit(0);
    }
    
    // Prepare file paths
    string tmpFile = filedir(argv[0]) + "qr_temp.txt";
    string scriptFile = filedir(argv[0]) + "qr_script.scr";
    
    // Modify the QR code generation part to use version-specific URL
    string pythonScriptUrl = "";
    
    // Récupérer l'URL du script Python pour la version actuelle
    string curlCmd = "curl -m 10 -s \"https://raw.githubusercontent.com/blaisebarrette/QRCode-ULP-for-Fusion-electronics/main/versions.json\" > \"" + tmpFile + "\"";
    system(curlCmd);
    
    string versionData[];
    if (fileread(versionData, tmpFile) > 0) {
        string jsonData = strjoin(versionData, '\n');
        string versionInfo = findVersionInfo(jsonData, VERSION);
        pythonScriptUrl = getScriptUrl(versionInfo);
    }
    system("rm \"" + tmpFile + "\"");
    
    if (pythonScriptUrl == "") {
        // Utiliser l'URL par défaut si on ne peut pas récupérer l'URL spécifique
        pythonScriptUrl = "https://blaisebarrette.pythonanywhere.com/generate-qr";
    }
    
    // Modifier la commande curl pour utiliser l'URL du script Python
    sprintf(curlCmd, "curl -m 10 -s \"%s?url=%s&size=%d\" > \"%s\"", pythonScriptUrl, Url, Size, tmpFile);
    
    if (system(curlCmd) != 0) {
        dlgMessageBox(
            "<b>Error: The QR Code service is temporarily unavailable.</b>\n\n" +
            "Please try again later.",
            "OK"
        );
        exit(1);
    }
    
    // Read QR code data
    string lines[];
    int nLines = fileread(lines, tmpFile);
    
    if (nLines <= 0) {
        dlgMessageBox("Error: Could not generate QR code. Please check your internet connection.");
        system("rm \"" + tmpFile + "\"");
        exit(1);
    }
    
    // Generate Eagle script
    output(scriptFile, "wt") {
        printf("GRID MIL;\n");
        printf("CHANGE LAYER %d;\n", LayerNumbers[SelectedLayer]);
        printf("SET WIRE_BEND 2;\n");
        
        // Create rectangles for QR code
        int moduleSize = Size / 21;
        // Check if bottom layer is selected (22 or 52)
        int isBottomLayer = (LayerNumbers[SelectedLayer] == 22 || LayerNumbers[SelectedLayer] == 52);
        
        for (int row = 0; row < nLines; row++) {
            string line = lines[row];
            for (int col = 0; col < strlen(line); col++) {
                if (line[col] == '1') {
                    int x1 = PosX + col * moduleSize - (Size/2);
                    int y1 = PosY + row * moduleSize - (Size/2);
                    int x2 = PosX + (col + 1) * moduleSize - (Size/2);
                    int y2 = PosY + (row + 1) * moduleSize - (Size/2);
                    
                    // Mirror X coordinates if bottom layer
                    if (isBottomLayer) {
                        int temp_x1 = x1;
                        x1 = -x2;
                        x2 = -temp_x1;
                    }
                    
                    printf("RECT (%d %d) (%d %d);\n", x1, y1, x2, y2);
                }
            }
        }
    }
    
    // Clean up with rm (MacOS)
    system("rm \"" + tmpFile + "\"");
    exit("SCRIPT '" + scriptFile + "'");
} 